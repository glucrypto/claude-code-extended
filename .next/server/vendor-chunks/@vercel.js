"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FF57VHLH.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@vercel/mcp-adapter/dist/chunk-FF57VHLH.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __async: () => (/* binding */ __async),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __objRest: () => (/* binding */ __objRest),\n/* harmony export */   __spreadProps: () => (/* binding */ __spreadProps),\n/* harmony export */   __spreadValues: () => (/* binding */ __spreadValues)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=chunk-FF57VHLH.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9tY3AtYWRhcHRlci9kaXN0L2NodW5rLUZGNTdWSExILm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUV5RTtBQUN6RTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nbHUvUHJvamVjdHMvYWxsL2NsYXVkZS1leHQvbm9kZV9tb2R1bGVzL0B2ZXJjZWwvbWNwLWFkYXB0ZXIvZGlzdC9jaHVuay1GRjU3VkhMSC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19hc3luYyA9IChfX3RoaXMsIF9fYXJndW1lbnRzLCBnZW5lcmF0b3IpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB2YXIgZnVsZmlsbGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWplY3RlZCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3IudGhyb3codmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBfX2FzeW5jLCBfX2NvbW1vbkpTLCBfX29ialJlc3QsIF9fc3ByZWFkUHJvcHMsIF9fc3ByZWFkVmFsdWVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXQuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GRjU3VkhMSC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FF57VHLH.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FGS6UOXD.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@vercel/mcp-adapter/dist/chunk-FGS6UOXD.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMcpRouteHandler: () => (/* binding */ createMcpRouteHandler),\n/* harmony export */   withAuthContext: () => (/* binding */ withAuthContext)\n/* harmony export */ });\n/* harmony import */ var _chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-FF57VHLH.mjs */ \"(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FF57VHLH.mjs\");\n/* harmony import */ var _modelcontextprotocol_sdk_server_mcp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @modelcontextprotocol/sdk/server/mcp.js */ \"(rsc)/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js\");\n/* harmony import */ var _modelcontextprotocol_sdk_server_sse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @modelcontextprotocol/sdk/server/sse.js */ \"(rsc)/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/sse.js\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var redis__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! redis */ \"(rsc)/./node_modules/redis/dist/index.js\");\n/* harmony import */ var net__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! net */ \"net\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var _modelcontextprotocol_sdk_server_streamableHttp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @modelcontextprotocol/sdk/server/streamableHttp.js */ \"(rsc)/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/streamableHttp.js\");\n/* harmony import */ var assert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! assert */ \"assert\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! events */ \"events\");\n\n\n\n\n\n\n\n\n\n\n\n\n// src/lib/log-helper.ts\nfunction createEvent(event) {\n  return (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__spreadProps)((0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__spreadValues)({}, event), {\n    timestamp: Date.now()\n  });\n}\n\n// src/lib/event-emitter.ts\nvar EventEmittingResponse = class extends http__WEBPACK_IMPORTED_MODULE_3__.ServerResponse {\n  constructor(req, onEvent, sessionId) {\n    super(req);\n    this.onEvent = onEvent;\n    this.sessionId = sessionId;\n    this.requestId = crypto.randomUUID();\n    this.startTime = Date.now();\n  }\n  emitEvent(event) {\n    if (this.onEvent) {\n      this.onEvent(\n        createEvent((0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__spreadProps)((0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__spreadValues)({}, event), {\n          sessionId: this.sessionId,\n          requestId: this.requestId\n        }))\n      );\n    }\n  }\n  startSession(transport, clientInfo) {\n    this.emitEvent({\n      type: \"SESSION_STARTED\",\n      transport,\n      clientInfo\n    });\n  }\n  endSession(transport) {\n    this.emitEvent({\n      type: \"SESSION_ENDED\",\n      transport\n    });\n  }\n  requestReceived(method, parameters) {\n    this.emitEvent({\n      type: \"REQUEST_RECEIVED\",\n      method,\n      parameters,\n      status: \"success\"\n    });\n  }\n  requestCompleted(method, result, error) {\n    this.emitEvent({\n      type: \"REQUEST_COMPLETED\",\n      method,\n      result,\n      duration: Date.now() - this.startTime,\n      status: error ? \"error\" : \"success\"\n    });\n    if (error) {\n      this.error(error, `Error executing request ${method}`, \"request\");\n    }\n  }\n  error(error, context, source = \"system\", severity = \"error\") {\n    this.emitEvent({\n      type: \"ERROR\",\n      error,\n      context,\n      source,\n      severity\n    });\n  }\n  end(chunk, encoding, cb) {\n    let finalChunk = chunk;\n    let finalEncoding = encoding;\n    let finalCallback = cb;\n    if (typeof chunk === \"function\") {\n      finalCallback = chunk;\n      finalChunk = void 0;\n      finalEncoding = void 0;\n    } else if (typeof encoding === \"function\") {\n      finalCallback = encoding;\n      finalEncoding = void 0;\n    }\n    return super.end(\n      finalChunk,\n      finalEncoding,\n      finalCallback\n    );\n  }\n};\nvar authContext = new async_hooks__WEBPACK_IMPORTED_MODULE_9__.AsyncLocalStorage();\nfunction getAuthContext() {\n  return authContext.getStore();\n}\nfunction withAuthContext(authInfo, callback) {\n  return authContext.run(authInfo, callback);\n}\n\n// src/next/mcp-api-handler.ts\nfunction createLogger(verboseLogs = false) {\n  return {\n    log: (...args) => {\n      if (verboseLogs)\n        console.log(...args);\n    },\n    error: (...args) => {\n      if (verboseLogs)\n        console.error(...args);\n    },\n    warn: (...args) => {\n      if (verboseLogs)\n        console.warn(...args);\n    },\n    info: (...args) => {\n      if (verboseLogs)\n        console.info(...args);\n    },\n    debug: (...args) => {\n      if (verboseLogs)\n        console.debug(...args);\n    }\n  };\n}\nfunction deriveEndpointsFromBasePath(basePath) {\n  const normalizedBasePath = basePath.replace(/\\/$/, \"\");\n  return {\n    streamableHttpEndpoint: `${normalizedBasePath}/mcp`,\n    sseEndpoint: `${normalizedBasePath}/sse`,\n    sseMessageEndpoint: `${normalizedBasePath}/message`\n  };\n}\nfunction calculateEndpoints({\n  basePath,\n  streamableHttpEndpoint = \"/mcp\",\n  sseEndpoint = \"/sse\",\n  sseMessageEndpoint = \"/message\"\n}) {\n  const {\n    streamableHttpEndpoint: fullStreamableHttpEndpoint,\n    sseEndpoint: fullSseEndpoint,\n    sseMessageEndpoint: fullSseMessageEndpoint\n  } = basePath != null ? deriveEndpointsFromBasePath(basePath) : {\n    streamableHttpEndpoint,\n    sseEndpoint,\n    sseMessageEndpoint\n  };\n  return {\n    streamableHttpEndpoint: fullStreamableHttpEndpoint,\n    sseEndpoint: fullSseEndpoint,\n    sseMessageEndpoint: fullSseMessageEndpoint\n  };\n}\nvar redisPublisher;\nvar redis;\nfunction initializeRedis(_0) {\n  return (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, arguments, function* ({\n    redisUrl,\n    logger\n  }) {\n    if (redis && redisPublisher) {\n      return { redis, redisPublisher };\n    }\n    if (!redisUrl) {\n      throw new Error(\"redisUrl is required\");\n    }\n    redis = (0,redis__WEBPACK_IMPORTED_MODULE_4__.createClient)({\n      url: redisUrl\n    });\n    redisPublisher = (0,redis__WEBPACK_IMPORTED_MODULE_4__.createClient)({\n      url: redisUrl\n    });\n    redis.on(\"error\", (err) => {\n      logger.error(\"Redis error\", err);\n    });\n    redisPublisher.on(\"error\", (err) => {\n      logger.error(\"Redis error\", err);\n    });\n    yield Promise.all([redis.connect(), redisPublisher.connect()]);\n    return { redis, redisPublisher };\n  });\n}\nfunction initializeMcpApiHandler(initializeServer, serverOptions = {}, config = {\n  redisUrl: process.env.REDIS_URL || process.env.KV_URL,\n  streamableHttpEndpoint: \"/mcp\",\n  sseEndpoint: \"/sse\",\n  sseMessageEndpoint: \"/message\",\n  basePath: \"\",\n  maxDuration: 60,\n  verboseLogs: false,\n  disableSse: false\n}) {\n  const {\n    redisUrl,\n    basePath,\n    streamableHttpEndpoint: explicitStreamableHttpEndpoint,\n    sseEndpoint: explicitSseEndpoint,\n    sseMessageEndpoint: explicitSseMessageEndpoint,\n    maxDuration,\n    verboseLogs,\n    disableSse\n  } = config;\n  const _a = serverOptions, {\n    serverInfo = {\n      name: \"mcp-typescript server on vercel\",\n      version: \"0.1.0\"\n    }\n  } = _a, mcpServerOptions = (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__objRest)(_a, [\n    \"serverInfo\"\n  ]);\n  const { streamableHttpEndpoint, sseEndpoint, sseMessageEndpoint } = calculateEndpoints({\n    basePath,\n    streamableHttpEndpoint: explicitStreamableHttpEndpoint,\n    sseEndpoint: explicitSseEndpoint,\n    sseMessageEndpoint: explicitSseMessageEndpoint\n  });\n  const logger = createLogger(verboseLogs);\n  let servers = [];\n  let statelessServer;\n  const statelessTransport = new _modelcontextprotocol_sdk_server_streamableHttp_js__WEBPACK_IMPORTED_MODULE_7__.StreamableHTTPServerTransport({\n    sessionIdGenerator: void 0\n  });\n  return function mcpApiHandler(req, res) {\n    return (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n      var _a2, _b, _c;\n      const url = new URL(req.url || \"\", \"https://example.com\");\n      if (url.pathname === streamableHttpEndpoint) {\n        if (req.method === \"GET\") {\n          logger.log(\"Received GET MCP request\");\n          res.writeHead(405).end(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32e3,\n                message: \"Method not allowed.\"\n              },\n              id: null\n            })\n          );\n          return;\n        }\n        if (req.method === \"DELETE\") {\n          logger.log(\"Received DELETE MCP request\");\n          res.writeHead(405).end(\n            JSON.stringify({\n              jsonrpc: \"2.0\",\n              error: {\n                code: -32e3,\n                message: \"Method not allowed.\"\n              },\n              id: null\n            })\n          );\n          return;\n        }\n        if (req.method === \"POST\") {\n          const eventRes = new EventEmittingResponse(\n            createFakeIncomingMessage(),\n            config.onEvent\n          );\n          if (!statelessServer) {\n            statelessServer = new _modelcontextprotocol_sdk_server_mcp_js__WEBPACK_IMPORTED_MODULE_1__.McpServer(serverInfo, mcpServerOptions);\n            yield initializeServer(statelessServer);\n            yield statelessServer.connect(statelessTransport);\n          }\n          let bodyContent;\n          const contentType = req.headers.get(\"content-type\") || \"\";\n          if (contentType.includes(\"application/json\")) {\n            bodyContent = yield req.json();\n          } else {\n            bodyContent = yield req.text();\n          }\n          const incomingRequest = createFakeIncomingMessage({\n            method: req.method,\n            url: req.url,\n            headers: Object.fromEntries(req.headers),\n            body: bodyContent,\n            auth: req.auth\n            // Use the auth info that should already be set by withMcpAuth\n          });\n          const wrappedRes = new EventEmittingResponse(\n            incomingRequest,\n            config.onEvent\n          );\n          Object.assign(wrappedRes, res);\n          try {\n            yield statelessTransport.handleRequest(incomingRequest, wrappedRes);\n            if (typeof bodyContent === \"object\" && bodyContent && \"method\" in bodyContent) {\n              eventRes.requestCompleted(\n                bodyContent.method,\n                bodyContent\n              );\n            }\n          } catch (error) {\n            if (typeof bodyContent === \"object\" && bodyContent && \"method\" in bodyContent) {\n              eventRes.requestCompleted(\n                bodyContent.method,\n                void 0,\n                error instanceof Error ? error : String(error)\n              );\n            }\n            throw error;\n          }\n        }\n      } else if (url.pathname === sseEndpoint) {\n        let logInContext2 = function(severity, ...messages) {\n          logs.push({\n            type: severity,\n            messages\n          });\n        };\n        if (disableSse) {\n          res.statusCode = 404;\n          res.end(\"Not found\");\n          return;\n        }\n        if (req.method !== \"GET\") {\n          logger.log(`Rejected SSE connection with method ${req.method}`);\n          res.writeHead(405, { \"Content-Type\": \"text/plain\" }).end(\"Method Not Allowed\");\n          return;\n        }\n        const acceptHeader = req.headers.get(\"accept\") || req.headers.get(\"Accept\");\n        if (acceptHeader && !acceptHeader.includes(\"text/event-stream\") && !acceptHeader.includes(\"*/*\") && !acceptHeader.includes(\"text/*\")) {\n          logger.log(\n            `Rejected SSE connection with incompatible Accept header: ${acceptHeader}`\n          );\n          res.writeHead(406, { \"Content-Type\": \"text/plain\" }).end(\"Not Acceptable\");\n          return;\n        }\n        const { redis: redis2, redisPublisher: redisPublisher2 } = yield initializeRedis({\n          redisUrl,\n          logger\n        });\n        logger.log(\"Got new SSE connection\");\n        assert__WEBPACK_IMPORTED_MODULE_8__(sseMessageEndpoint, \"sseMessageEndpoint is required\");\n        const transport = new _modelcontextprotocol_sdk_server_sse_js__WEBPACK_IMPORTED_MODULE_2__.SSEServerTransport(sseMessageEndpoint, res);\n        const sessionId = transport.sessionId;\n        const eventRes = new EventEmittingResponse(\n          createFakeIncomingMessage(),\n          config.onEvent,\n          sessionId\n        );\n        eventRes.startSession(\"SSE\", {\n          userAgent: (_a2 = req.headers.get(\"user-agent\")) != null ? _a2 : void 0,\n          ip: (_c = (_b = req.headers.get(\"x-forwarded-for\")) != null ? _b : req.headers.get(\"x-real-ip\")) != null ? _c : void 0\n        });\n        const server = new _modelcontextprotocol_sdk_server_mcp_js__WEBPACK_IMPORTED_MODULE_1__.McpServer(serverInfo, serverOptions);\n        yield initializeServer(server);\n        servers.push(server);\n        server.server.onclose = () => {\n          logger.log(\"SSE connection closed\");\n          eventRes.endSession(\"SSE\");\n          servers = servers.filter((s) => s !== server);\n        };\n        let logs = [];\n        const handleMessage = (message) => (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n          logger.log(\"Received message from Redis\", message);\n          logInContext2(\"log\", \"Received message from Redis\", message);\n          const request = JSON.parse(message);\n          const req2 = createFakeIncomingMessage({\n            method: request.method,\n            url: request.url,\n            headers: request.headers,\n            body: request.body\n          });\n          const syntheticRes = new EventEmittingResponse(\n            req2,\n            config.onEvent,\n            sessionId\n          );\n          let status = 100;\n          let body = \"\";\n          syntheticRes.writeHead = (statusCode) => {\n            status = statusCode;\n            return syntheticRes;\n          };\n          syntheticRes.end = (b) => {\n            body = b;\n            return syntheticRes;\n          };\n          try {\n            yield transport.handlePostMessage(req2, syntheticRes);\n            if (typeof request.body === \"object\" && request.body && \"method\" in request.body) {\n              try {\n                const result = JSON.parse(body);\n                eventRes.requestCompleted(request.body.method, result);\n              } catch (e) {\n                eventRes.requestCompleted(request.body.method, body);\n              }\n            }\n          } catch (error) {\n            eventRes.error(\n              error instanceof Error ? error : String(error),\n              \"Error handling SSE message\",\n              \"session\"\n            );\n            throw error;\n          }\n          yield redisPublisher2.publish(\n            `responses:${sessionId}:${request.requestId}`,\n            JSON.stringify({\n              status,\n              body\n            })\n          );\n          if (status >= 200 && status < 300) {\n            logInContext2(\n              \"log\",\n              `Request ${sessionId}:${request.requestId} succeeded: ${body}`\n            );\n          } else {\n            logInContext2(\n              \"error\",\n              `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`\n            );\n            eventRes.error(\n              `Request failed with status ${status}`,\n              body,\n              \"session\"\n            );\n          }\n        });\n        const interval = setInterval(() => {\n          for (const log of logs) {\n            logger[log.type](...log.messages);\n          }\n          logs = [];\n        }, 100);\n        yield redis2.subscribe(`requests:${sessionId}`, handleMessage);\n        logger.log(`Subscribed to requests:${sessionId}`);\n        let timeout;\n        let resolveTimeout;\n        const waitPromise = new Promise((resolve) => {\n          resolveTimeout = resolve;\n          timeout = setTimeout(() => {\n            resolve(\"max duration reached\");\n          }, (maxDuration != null ? maxDuration : 60) * 1e3);\n        });\n        function cleanup() {\n          return (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n            clearTimeout(timeout);\n            clearInterval(interval);\n            yield redis2.unsubscribe(`requests:${sessionId}`, handleMessage);\n            logger.log(\"Done\");\n            res.statusCode = 200;\n            res.end();\n          });\n        }\n        req.signal.addEventListener(\n          \"abort\",\n          () => resolveTimeout(\"client hang up\")\n        );\n        yield server.connect(transport);\n        const closeReason = yield waitPromise;\n        logger.log(closeReason);\n        yield cleanup();\n      } else if (url.pathname === sseMessageEndpoint) {\n        if (disableSse) {\n          res.statusCode = 404;\n          res.end(\"Not found\");\n          return;\n        }\n        const { redis: redis2, redisPublisher: redisPublisher2 } = yield initializeRedis({\n          redisUrl,\n          logger\n        });\n        logger.log(\"Received message\");\n        const body = yield req.text();\n        let parsedBody;\n        try {\n          parsedBody = JSON.parse(body);\n        } catch (e) {\n          parsedBody = body;\n        }\n        const sessionId = url.searchParams.get(\"sessionId\") || \"\";\n        if (!sessionId) {\n          res.statusCode = 400;\n          res.end(\"No sessionId provided\");\n          return;\n        }\n        const requestId = crypto.randomUUID();\n        const serializedRequest = {\n          requestId,\n          url: req.url || \"\",\n          method: req.method || \"\",\n          body: parsedBody,\n          headers: Object.fromEntries(req.headers.entries())\n        };\n        let timeout;\n        let hasResponded = false;\n        const sendResponse = (status, body2) => {\n          if (!hasResponded) {\n            hasResponded = true;\n            clearTimeout(timeout);\n            res.statusCode = status;\n            res.end(body2);\n          }\n        };\n        yield redis2.subscribe(\n          `responses:${sessionId}:${requestId}`,\n          (message) => {\n            try {\n              const response = JSON.parse(message);\n              sendResponse(response.status, response.body);\n            } catch (error) {\n              logger.error(\"Failed to parse response message:\", error);\n              sendResponse(500, \"Internal server error\");\n            }\n          }\n        );\n        yield redisPublisher2.publish(\n          `requests:${sessionId}`,\n          JSON.stringify(serializedRequest)\n        );\n        logger.log(`Published requests:${sessionId}`, serializedRequest);\n        timeout = setTimeout(() => (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n          yield redis2.unsubscribe(`responses:${sessionId}:${requestId}`);\n          sendResponse(408, \"Request timed out\");\n        }), 10 * 1e3);\n        res.on(\"close\", () => (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n          hasResponded = true;\n          clearTimeout(timeout);\n          yield redis2.unsubscribe(`responses:${sessionId}:${requestId}`);\n        }));\n      } else {\n        res.statusCode = 404;\n        res.end(\"Not found\");\n      }\n    });\n  };\n}\nfunction createFakeIncomingMessage(options = {}) {\n  const {\n    method = \"GET\",\n    url = \"/\",\n    headers = {},\n    body = null,\n    socket = new net__WEBPACK_IMPORTED_MODULE_5__.Socket()\n  } = options;\n  const readable = new stream__WEBPACK_IMPORTED_MODULE_6__.Readable();\n  readable._read = () => {\n  };\n  if (body) {\n    if (typeof body === \"string\") {\n      readable.push(body);\n    } else if (Buffer.isBuffer(body)) {\n      readable.push(body);\n    } else {\n      const bodyString = JSON.stringify(body);\n      readable.push(bodyString);\n    }\n    readable.push(null);\n  } else {\n    readable.push(null);\n  }\n  const req = new http__WEBPACK_IMPORTED_MODULE_3__.IncomingMessage(socket);\n  req.method = method;\n  req.url = url;\n  req.headers = headers;\n  const auth = options.auth || getAuthContext();\n  if (auth) {\n    req.auth = auth;\n  }\n  req.push = readable.push.bind(readable);\n  req.read = readable.read.bind(readable);\n  req.on = readable.on.bind(readable);\n  req.pipe = readable.pipe.bind(readable);\n  return req;\n}\nfunction createServerResponseAdapter(signal, fn) {\n  let writeHeadResolver;\n  const writeHeadPromise = new Promise((resolve) => {\n    writeHeadResolver = resolve;\n  });\n  return new Promise((resolve) => {\n    let controller;\n    let shouldClose = false;\n    let wroteHead = false;\n    let statusCode = 200;\n    let headers;\n    const writeHead = (code, headersArg) => {\n      if (typeof headersArg === \"string\") {\n        throw new Error(\"Status message of writeHead not supported\");\n      }\n      statusCode = code;\n      headers = headersArg;\n      wroteHead = true;\n      writeHeadResolver({\n        statusCode,\n        headers\n      });\n      return fakeServerResponse;\n    };\n    const bufferedData = [];\n    const write = (chunk, encoding) => {\n      if (encoding) {\n        throw new Error(\"Encoding not supported\");\n      }\n      if (chunk instanceof Buffer) {\n        throw new Error(\"Buffer not supported\");\n      }\n      if (!wroteHead) {\n        writeHead(statusCode, headers);\n      }\n      if (!controller) {\n        bufferedData.push(new TextEncoder().encode(chunk));\n        return true;\n      }\n      controller.enqueue(new TextEncoder().encode(chunk));\n      return true;\n    };\n    const eventEmitter = new events__WEBPACK_IMPORTED_MODULE_10__.EventEmitter();\n    const fakeServerResponse = {\n      writeHead,\n      write,\n      end: (data) => {\n        if (data) {\n          write(data);\n        }\n        if (!controller) {\n          shouldClose = true;\n          return fakeServerResponse;\n        }\n        try {\n          controller.close();\n        } catch (e) {\n        }\n        return fakeServerResponse;\n      },\n      on: (event, listener) => {\n        eventEmitter.on(event, listener);\n        return fakeServerResponse;\n      },\n      get statusCode() {\n        return statusCode;\n      },\n      set statusCode(code) {\n        statusCode = code;\n        if (wroteHead) {\n          writeHeadResolver({\n            statusCode,\n            headers\n          });\n        }\n      }\n    };\n    signal.addEventListener(\"abort\", () => {\n      eventEmitter.emit(\"close\");\n    });\n    void fn(fakeServerResponse);\n    void (() => (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_0__.__async)(this, null, function* () {\n      const head = yield writeHeadPromise;\n      const response = new Response(\n        new ReadableStream({\n          start(c) {\n            controller = c;\n            for (const chunk of bufferedData) {\n              controller.enqueue(chunk);\n            }\n            if (shouldClose) {\n              controller.close();\n            }\n          }\n        }),\n        {\n          status: head.statusCode,\n          headers: head.headers\n        }\n      );\n      resolve(response);\n    }))();\n  });\n}\n\n// src/next/index.ts\nfunction createMcpRouteHandler(initializeServer, serverOptions, config) {\n  const mcpHandler = initializeMcpApiHandler(\n    initializeServer,\n    serverOptions,\n    config\n  );\n  return (request) => {\n    return createServerResponseAdapter(request.signal, (res) => {\n      mcpHandler(request, res);\n    });\n  };\n}\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=chunk-FGS6UOXD.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9tY3AtYWRhcHRlci9kaXN0L2NodW5rLUZHUzZVT1hELm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXlGO0FBQ3JCO0FBQ1M7QUFDdEI7QUFDbEI7QUFDUjtBQUNLO0FBQ2lFO0FBQ3ZFO0FBQ29CO0FBQ1Y7O0FBRXRDO0FBQ0E7QUFDQSxTQUFTLGtFQUFhLENBQUMsbUVBQWMsR0FBRztBQUN4QztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDBDQUEwQyxnREFBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBYSxDQUFDLG1FQUFjLEdBQUc7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMERBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFL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LEtBQUs7QUFDTDtBQUNBLGdCQUFnQiw0REFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVrRDtBQUNsRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nbHUvUHJvamVjdHMvYWxsL2NsYXVkZS1leHQvbm9kZV9tb2R1bGVzL0B2ZXJjZWwvbWNwLWFkYXB0ZXIvZGlzdC9jaHVuay1GR1M2VU9YRC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19vYmpSZXN0LCBfX2FzeW5jLCBfX3NwcmVhZFByb3BzLCBfX3NwcmVhZFZhbHVlcyB9IGZyb20gJy4vY2h1bmstRkY1N1ZITEgubWpzJztcbmltcG9ydCB7IE1jcFNlcnZlciB9IGZyb20gJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL21jcC5qcyc7XG5pbXBvcnQgeyBTU0VTZXJ2ZXJUcmFuc3BvcnQgfSBmcm9tICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NlcnZlci9zc2UuanMnO1xuaW1wb3J0IHsgU2VydmVyUmVzcG9uc2UsIEluY29taW5nTWVzc2FnZSB9IGZyb20gJ2h0dHAnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAncmVkaXMnO1xuaW1wb3J0IHsgU29ja2V0IH0gZnJvbSAnbmV0JztcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCB7IFN0cmVhbWFibGVIVFRQU2VydmVyVHJhbnNwb3J0IH0gZnJvbSAnQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvc3RyZWFtYWJsZUh0dHAuanMnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSBmcm9tICdhc3luY19ob29rcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG4vLyBzcmMvbGliL2xvZy1oZWxwZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBldmVudCksIHtcbiAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgfSk7XG59XG5cbi8vIHNyYy9saWIvZXZlbnQtZW1pdHRlci50c1xudmFyIEV2ZW50RW1pdHRpbmdSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgU2VydmVyUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXEsIG9uRXZlbnQsIHNlc3Npb25JZCkge1xuICAgIHN1cGVyKHJlcSk7XG4gICAgdGhpcy5vbkV2ZW50ID0gb25FdmVudDtcbiAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIGVtaXRFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLm9uRXZlbnQpIHtcbiAgICAgIHRoaXMub25FdmVudChcbiAgICAgICAgY3JlYXRlRXZlbnQoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgZXZlbnQpLCB7XG4gICAgICAgICAgc2Vzc2lvbklkOiB0aGlzLnNlc3Npb25JZCxcbiAgICAgICAgICByZXF1ZXN0SWQ6IHRoaXMucmVxdWVzdElkXG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRTZXNzaW9uKHRyYW5zcG9ydCwgY2xpZW50SW5mbykge1xuICAgIHRoaXMuZW1pdEV2ZW50KHtcbiAgICAgIHR5cGU6IFwiU0VTU0lPTl9TVEFSVEVEXCIsXG4gICAgICB0cmFuc3BvcnQsXG4gICAgICBjbGllbnRJbmZvXG4gICAgfSk7XG4gIH1cbiAgZW5kU2Vzc2lvbih0cmFuc3BvcnQpIHtcbiAgICB0aGlzLmVtaXRFdmVudCh7XG4gICAgICB0eXBlOiBcIlNFU1NJT05fRU5ERURcIixcbiAgICAgIHRyYW5zcG9ydFxuICAgIH0pO1xuICB9XG4gIHJlcXVlc3RSZWNlaXZlZChtZXRob2QsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLmVtaXRFdmVudCh7XG4gICAgICB0eXBlOiBcIlJFUVVFU1RfUkVDRUlWRURcIixcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtZXRlcnMsXG4gICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiXG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdENvbXBsZXRlZChtZXRob2QsIHJlc3VsdCwgZXJyb3IpIHtcbiAgICB0aGlzLmVtaXRFdmVudCh7XG4gICAgICB0eXBlOiBcIlJFUVVFU1RfQ09NUExFVEVEXCIsXG4gICAgICBtZXRob2QsXG4gICAgICByZXN1bHQsXG4gICAgICBkdXJhdGlvbjogRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lLFxuICAgICAgc3RhdHVzOiBlcnJvciA/IFwiZXJyb3JcIiA6IFwic3VjY2Vzc1wiXG4gICAgfSk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB0aGlzLmVycm9yKGVycm9yLCBgRXJyb3IgZXhlY3V0aW5nIHJlcXVlc3QgJHttZXRob2R9YCwgXCJyZXF1ZXN0XCIpO1xuICAgIH1cbiAgfVxuICBlcnJvcihlcnJvciwgY29udGV4dCwgc291cmNlID0gXCJzeXN0ZW1cIiwgc2V2ZXJpdHkgPSBcImVycm9yXCIpIHtcbiAgICB0aGlzLmVtaXRFdmVudCh7XG4gICAgICB0eXBlOiBcIkVSUk9SXCIsXG4gICAgICBlcnJvcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBzb3VyY2UsXG4gICAgICBzZXZlcml0eVxuICAgIH0pO1xuICB9XG4gIGVuZChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgbGV0IGZpbmFsQ2h1bmsgPSBjaHVuaztcbiAgICBsZXQgZmluYWxFbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIGxldCBmaW5hbENhbGxiYWNrID0gY2I7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmaW5hbENhbGxiYWNrID0gY2h1bms7XG4gICAgICBmaW5hbENodW5rID0gdm9pZCAwO1xuICAgICAgZmluYWxFbmNvZGluZyA9IHZvaWQgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmaW5hbENhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgICBmaW5hbEVuY29kaW5nID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW5kKFxuICAgICAgZmluYWxDaHVuayxcbiAgICAgIGZpbmFsRW5jb2RpbmcsXG4gICAgICBmaW5hbENhbGxiYWNrXG4gICAgKTtcbiAgfVxufTtcbnZhciBhdXRoQ29udGV4dCA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZSgpO1xuZnVuY3Rpb24gZ2V0QXV0aENvbnRleHQoKSB7XG4gIHJldHVybiBhdXRoQ29udGV4dC5nZXRTdG9yZSgpO1xufVxuZnVuY3Rpb24gd2l0aEF1dGhDb250ZXh0KGF1dGhJbmZvLCBjYWxsYmFjaykge1xuICByZXR1cm4gYXV0aENvbnRleHQucnVuKGF1dGhJbmZvLCBjYWxsYmFjayk7XG59XG5cbi8vIHNyYy9uZXh0L21jcC1hcGktaGFuZGxlci50c1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKHZlcmJvc2VMb2dzID0gZmFsc2UpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2c6ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodmVyYm9zZUxvZ3MpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgZXJyb3I6ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAodmVyYm9zZUxvZ3MpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgfSxcbiAgICB3YXJuOiAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHZlcmJvc2VMb2dzKVxuICAgICAgICBjb25zb2xlLndhcm4oLi4uYXJncyk7XG4gICAgfSxcbiAgICBpbmZvOiAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHZlcmJvc2VMb2dzKVxuICAgICAgICBjb25zb2xlLmluZm8oLi4uYXJncyk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKC4uLmFyZ3MpID0+IHtcbiAgICAgIGlmICh2ZXJib3NlTG9ncylcbiAgICAgICAgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZXJpdmVFbmRwb2ludHNGcm9tQmFzZVBhdGgoYmFzZVBhdGgpIHtcbiAgY29uc3Qgbm9ybWFsaXplZEJhc2VQYXRoID0gYmFzZVBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICByZXR1cm4ge1xuICAgIHN0cmVhbWFibGVIdHRwRW5kcG9pbnQ6IGAke25vcm1hbGl6ZWRCYXNlUGF0aH0vbWNwYCxcbiAgICBzc2VFbmRwb2ludDogYCR7bm9ybWFsaXplZEJhc2VQYXRofS9zc2VgLFxuICAgIHNzZU1lc3NhZ2VFbmRwb2ludDogYCR7bm9ybWFsaXplZEJhc2VQYXRofS9tZXNzYWdlYFxuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRW5kcG9pbnRzKHtcbiAgYmFzZVBhdGgsXG4gIHN0cmVhbWFibGVIdHRwRW5kcG9pbnQgPSBcIi9tY3BcIixcbiAgc3NlRW5kcG9pbnQgPSBcIi9zc2VcIixcbiAgc3NlTWVzc2FnZUVuZHBvaW50ID0gXCIvbWVzc2FnZVwiXG59KSB7XG4gIGNvbnN0IHtcbiAgICBzdHJlYW1hYmxlSHR0cEVuZHBvaW50OiBmdWxsU3RyZWFtYWJsZUh0dHBFbmRwb2ludCxcbiAgICBzc2VFbmRwb2ludDogZnVsbFNzZUVuZHBvaW50LFxuICAgIHNzZU1lc3NhZ2VFbmRwb2ludDogZnVsbFNzZU1lc3NhZ2VFbmRwb2ludFxuICB9ID0gYmFzZVBhdGggIT0gbnVsbCA/IGRlcml2ZUVuZHBvaW50c0Zyb21CYXNlUGF0aChiYXNlUGF0aCkgOiB7XG4gICAgc3RyZWFtYWJsZUh0dHBFbmRwb2ludCxcbiAgICBzc2VFbmRwb2ludCxcbiAgICBzc2VNZXNzYWdlRW5kcG9pbnRcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW1hYmxlSHR0cEVuZHBvaW50OiBmdWxsU3RyZWFtYWJsZUh0dHBFbmRwb2ludCxcbiAgICBzc2VFbmRwb2ludDogZnVsbFNzZUVuZHBvaW50LFxuICAgIHNzZU1lc3NhZ2VFbmRwb2ludDogZnVsbFNzZU1lc3NhZ2VFbmRwb2ludFxuICB9O1xufVxudmFyIHJlZGlzUHVibGlzaGVyO1xudmFyIHJlZGlzO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlZGlzKF8wKSB7XG4gIHJldHVybiBfX2FzeW5jKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qICh7XG4gICAgcmVkaXNVcmwsXG4gICAgbG9nZ2VyXG4gIH0pIHtcbiAgICBpZiAocmVkaXMgJiYgcmVkaXNQdWJsaXNoZXIpIHtcbiAgICAgIHJldHVybiB7IHJlZGlzLCByZWRpc1B1Ymxpc2hlciB9O1xuICAgIH1cbiAgICBpZiAoIXJlZGlzVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWRpc1VybCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgcmVkaXMgPSBjcmVhdGVDbGllbnQoe1xuICAgICAgdXJsOiByZWRpc1VybFxuICAgIH0pO1xuICAgIHJlZGlzUHVibGlzaGVyID0gY3JlYXRlQ2xpZW50KHtcbiAgICAgIHVybDogcmVkaXNVcmxcbiAgICB9KTtcbiAgICByZWRpcy5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlJlZGlzIGVycm9yXCIsIGVycik7XG4gICAgfSk7XG4gICAgcmVkaXNQdWJsaXNoZXIub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJSZWRpcyBlcnJvclwiLCBlcnIpO1xuICAgIH0pO1xuICAgIHlpZWxkIFByb21pc2UuYWxsKFtyZWRpcy5jb25uZWN0KCksIHJlZGlzUHVibGlzaGVyLmNvbm5lY3QoKV0pO1xuICAgIHJldHVybiB7IHJlZGlzLCByZWRpc1B1Ymxpc2hlciB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVNY3BBcGlIYW5kbGVyKGluaXRpYWxpemVTZXJ2ZXIsIHNlcnZlck9wdGlvbnMgPSB7fSwgY29uZmlnID0ge1xuICByZWRpc1VybDogcHJvY2Vzcy5lbnYuUkVESVNfVVJMIHx8IHByb2Nlc3MuZW52LktWX1VSTCxcbiAgc3RyZWFtYWJsZUh0dHBFbmRwb2ludDogXCIvbWNwXCIsXG4gIHNzZUVuZHBvaW50OiBcIi9zc2VcIixcbiAgc3NlTWVzc2FnZUVuZHBvaW50OiBcIi9tZXNzYWdlXCIsXG4gIGJhc2VQYXRoOiBcIlwiLFxuICBtYXhEdXJhdGlvbjogNjAsXG4gIHZlcmJvc2VMb2dzOiBmYWxzZSxcbiAgZGlzYWJsZVNzZTogZmFsc2Vcbn0pIHtcbiAgY29uc3Qge1xuICAgIHJlZGlzVXJsLFxuICAgIGJhc2VQYXRoLFxuICAgIHN0cmVhbWFibGVIdHRwRW5kcG9pbnQ6IGV4cGxpY2l0U3RyZWFtYWJsZUh0dHBFbmRwb2ludCxcbiAgICBzc2VFbmRwb2ludDogZXhwbGljaXRTc2VFbmRwb2ludCxcbiAgICBzc2VNZXNzYWdlRW5kcG9pbnQ6IGV4cGxpY2l0U3NlTWVzc2FnZUVuZHBvaW50LFxuICAgIG1heER1cmF0aW9uLFxuICAgIHZlcmJvc2VMb2dzLFxuICAgIGRpc2FibGVTc2VcbiAgfSA9IGNvbmZpZztcbiAgY29uc3QgX2EgPSBzZXJ2ZXJPcHRpb25zLCB7XG4gICAgc2VydmVySW5mbyA9IHtcbiAgICAgIG5hbWU6IFwibWNwLXR5cGVzY3JpcHQgc2VydmVyIG9uIHZlcmNlbFwiLFxuICAgICAgdmVyc2lvbjogXCIwLjEuMFwiXG4gICAgfVxuICB9ID0gX2EsIG1jcFNlcnZlck9wdGlvbnMgPSBfX29ialJlc3QoX2EsIFtcbiAgICBcInNlcnZlckluZm9cIlxuICBdKTtcbiAgY29uc3QgeyBzdHJlYW1hYmxlSHR0cEVuZHBvaW50LCBzc2VFbmRwb2ludCwgc3NlTWVzc2FnZUVuZHBvaW50IH0gPSBjYWxjdWxhdGVFbmRwb2ludHMoe1xuICAgIGJhc2VQYXRoLFxuICAgIHN0cmVhbWFibGVIdHRwRW5kcG9pbnQ6IGV4cGxpY2l0U3RyZWFtYWJsZUh0dHBFbmRwb2ludCxcbiAgICBzc2VFbmRwb2ludDogZXhwbGljaXRTc2VFbmRwb2ludCxcbiAgICBzc2VNZXNzYWdlRW5kcG9pbnQ6IGV4cGxpY2l0U3NlTWVzc2FnZUVuZHBvaW50XG4gIH0pO1xuICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIodmVyYm9zZUxvZ3MpO1xuICBsZXQgc2VydmVycyA9IFtdO1xuICBsZXQgc3RhdGVsZXNzU2VydmVyO1xuICBjb25zdCBzdGF0ZWxlc3NUcmFuc3BvcnQgPSBuZXcgU3RyZWFtYWJsZUhUVFBTZXJ2ZXJUcmFuc3BvcnQoe1xuICAgIHNlc3Npb25JZEdlbmVyYXRvcjogdm9pZCAwXG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gbWNwQXBpSGFuZGxlcihyZXEsIHJlcykge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EyLCBfYiwgX2M7XG4gICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwgfHwgXCJcIiwgXCJodHRwczovL2V4YW1wbGUuY29tXCIpO1xuICAgICAgaWYgKHVybC5wYXRobmFtZSA9PT0gc3RyZWFtYWJsZUh0dHBFbmRwb2ludCkge1xuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJSZWNlaXZlZCBHRVQgTUNQIHJlcXVlc3RcIik7XG4gICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDUpLmVuZChcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAtMzJlMyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1ldGhvZCBub3QgYWxsb3dlZC5cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJERUxFVEVcIikge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJSZWNlaXZlZCBERUxFVEUgTUNQIHJlcXVlc3RcIik7XG4gICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDUpLmVuZChcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAtMzJlMyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1ldGhvZCBub3QgYWxsb3dlZC5cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxLm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcbiAgICAgICAgICBjb25zdCBldmVudFJlcyA9IG5ldyBFdmVudEVtaXR0aW5nUmVzcG9uc2UoXG4gICAgICAgICAgICBjcmVhdGVGYWtlSW5jb21pbmdNZXNzYWdlKCksXG4gICAgICAgICAgICBjb25maWcub25FdmVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFzdGF0ZWxlc3NTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHN0YXRlbGVzc1NlcnZlciA9IG5ldyBNY3BTZXJ2ZXIoc2VydmVySW5mbywgbWNwU2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB5aWVsZCBpbml0aWFsaXplU2VydmVyKHN0YXRlbGVzc1NlcnZlcik7XG4gICAgICAgICAgICB5aWVsZCBzdGF0ZWxlc3NTZXJ2ZXIuY29ubmVjdChzdGF0ZWxlc3NUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgYm9keUNvbnRlbnQ7XG4gICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXEuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICBib2R5Q29udGVudCA9IHlpZWxkIHJlcS5qc29uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHlDb250ZW50ID0geWllbGQgcmVxLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5jb21pbmdSZXF1ZXN0ID0gY3JlYXRlRmFrZUluY29taW5nTWVzc2FnZSh7XG4gICAgICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgICAgICB1cmw6IHJlcS51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVxLmhlYWRlcnMpLFxuICAgICAgICAgICAgYm9keTogYm9keUNvbnRlbnQsXG4gICAgICAgICAgICBhdXRoOiByZXEuYXV0aFxuICAgICAgICAgICAgLy8gVXNlIHRoZSBhdXRoIGluZm8gdGhhdCBzaG91bGQgYWxyZWFkeSBiZSBzZXQgYnkgd2l0aE1jcEF1dGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkUmVzID0gbmV3IEV2ZW50RW1pdHRpbmdSZXNwb25zZShcbiAgICAgICAgICAgIGluY29taW5nUmVxdWVzdCxcbiAgICAgICAgICAgIGNvbmZpZy5vbkV2ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRSZXMsIHJlcyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHlpZWxkIHN0YXRlbGVzc1RyYW5zcG9ydC5oYW5kbGVSZXF1ZXN0KGluY29taW5nUmVxdWVzdCwgd3JhcHBlZFJlcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvZHlDb250ZW50ID09PSBcIm9iamVjdFwiICYmIGJvZHlDb250ZW50ICYmIFwibWV0aG9kXCIgaW4gYm9keUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgZXZlbnRSZXMucmVxdWVzdENvbXBsZXRlZChcbiAgICAgICAgICAgICAgICBib2R5Q29udGVudC5tZXRob2QsXG4gICAgICAgICAgICAgICAgYm9keUNvbnRlbnRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5Q29udGVudCA9PT0gXCJvYmplY3RcIiAmJiBib2R5Q29udGVudCAmJiBcIm1ldGhvZFwiIGluIGJvZHlDb250ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50UmVzLnJlcXVlc3RDb21wbGV0ZWQoXG4gICAgICAgICAgICAgICAgYm9keUNvbnRlbnQubWV0aG9kLFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodXJsLnBhdGhuYW1lID09PSBzc2VFbmRwb2ludCkge1xuICAgICAgICBsZXQgbG9nSW5Db250ZXh0MiA9IGZ1bmN0aW9uKHNldmVyaXR5LCAuLi5tZXNzYWdlcykge1xuICAgICAgICAgIGxvZ3MucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBzZXZlcml0eSxcbiAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkaXNhYmxlU3NlKSB7XG4gICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgcmVzLmVuZChcIk5vdCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcS5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKGBSZWplY3RlZCBTU0UgY29ubmVjdGlvbiB3aXRoIG1ldGhvZCAke3JlcS5tZXRob2R9YCk7XG4gICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDUsIHsgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCIgfSkuZW5kKFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NlcHRIZWFkZXIgPSByZXEuaGVhZGVycy5nZXQoXCJhY2NlcHRcIikgfHwgcmVxLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpO1xuICAgICAgICBpZiAoYWNjZXB0SGVhZGVyICYmICFhY2NlcHRIZWFkZXIuaW5jbHVkZXMoXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiKSAmJiAhYWNjZXB0SGVhZGVyLmluY2x1ZGVzKFwiKi8qXCIpICYmICFhY2NlcHRIZWFkZXIuaW5jbHVkZXMoXCJ0ZXh0LypcIikpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFxuICAgICAgICAgICAgYFJlamVjdGVkIFNTRSBjb25uZWN0aW9uIHdpdGggaW5jb21wYXRpYmxlIEFjY2VwdCBoZWFkZXI6ICR7YWNjZXB0SGVhZGVyfWBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlcy53cml0ZUhlYWQoNDA2LCB7IFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpblwiIH0pLmVuZChcIk5vdCBBY2NlcHRhYmxlXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHJlZGlzOiByZWRpczIsIHJlZGlzUHVibGlzaGVyOiByZWRpc1B1Ymxpc2hlcjIgfSA9IHlpZWxkIGluaXRpYWxpemVSZWRpcyh7XG4gICAgICAgICAgcmVkaXNVcmwsXG4gICAgICAgICAgbG9nZ2VyXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIubG9nKFwiR290IG5ldyBTU0UgY29ubmVjdGlvblwiKTtcbiAgICAgICAgYXNzZXJ0KHNzZU1lc3NhZ2VFbmRwb2ludCwgXCJzc2VNZXNzYWdlRW5kcG9pbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBTU0VTZXJ2ZXJUcmFuc3BvcnQoc3NlTWVzc2FnZUVuZHBvaW50LCByZXMpO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSB0cmFuc3BvcnQuc2Vzc2lvbklkO1xuICAgICAgICBjb25zdCBldmVudFJlcyA9IG5ldyBFdmVudEVtaXR0aW5nUmVzcG9uc2UoXG4gICAgICAgICAgY3JlYXRlRmFrZUluY29taW5nTWVzc2FnZSgpLFxuICAgICAgICAgIGNvbmZpZy5vbkV2ZW50LFxuICAgICAgICAgIHNlc3Npb25JZFxuICAgICAgICApO1xuICAgICAgICBldmVudFJlcy5zdGFydFNlc3Npb24oXCJTU0VcIiwge1xuICAgICAgICAgIHVzZXJBZ2VudDogKF9hMiA9IHJlcS5oZWFkZXJzLmdldChcInVzZXItYWdlbnRcIikpICE9IG51bGwgPyBfYTIgOiB2b2lkIDAsXG4gICAgICAgICAgaXA6IChfYyA9IChfYiA9IHJlcS5oZWFkZXJzLmdldChcIngtZm9yd2FyZGVkLWZvclwiKSkgIT0gbnVsbCA/IF9iIDogcmVxLmhlYWRlcnMuZ2V0KFwieC1yZWFsLWlwXCIpKSAhPSBudWxsID8gX2MgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IG5ldyBNY3BTZXJ2ZXIoc2VydmVySW5mbywgc2VydmVyT3B0aW9ucyk7XG4gICAgICAgIHlpZWxkIGluaXRpYWxpemVTZXJ2ZXIoc2VydmVyKTtcbiAgICAgICAgc2VydmVycy5wdXNoKHNlcnZlcik7XG4gICAgICAgIHNlcnZlci5zZXJ2ZXIub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICBsb2dnZXIubG9nKFwiU1NFIGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgICAgICAgIGV2ZW50UmVzLmVuZFNlc3Npb24oXCJTU0VcIik7XG4gICAgICAgICAgc2VydmVycyA9IHNlcnZlcnMuZmlsdGVyKChzKSA9PiBzICE9PSBzZXJ2ZXIpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgbG9ncyA9IFtdO1xuICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKG1lc3NhZ2UpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKFwiUmVjZWl2ZWQgbWVzc2FnZSBmcm9tIFJlZGlzXCIsIG1lc3NhZ2UpO1xuICAgICAgICAgIGxvZ0luQ29udGV4dDIoXCJsb2dcIiwgXCJSZWNlaXZlZCBtZXNzYWdlIGZyb20gUmVkaXNcIiwgbWVzc2FnZSk7XG4gICAgICAgICAgY29uc3QgcmVxdWVzdCA9IEpTT04ucGFyc2UobWVzc2FnZSk7XG4gICAgICAgICAgY29uc3QgcmVxMiA9IGNyZWF0ZUZha2VJbmNvbWluZ01lc3NhZ2Uoe1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiByZXF1ZXN0LmJvZHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzeW50aGV0aWNSZXMgPSBuZXcgRXZlbnRFbWl0dGluZ1Jlc3BvbnNlKFxuICAgICAgICAgICAgcmVxMixcbiAgICAgICAgICAgIGNvbmZpZy5vbkV2ZW50LFxuICAgICAgICAgICAgc2Vzc2lvbklkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBsZXQgc3RhdHVzID0gMTAwO1xuICAgICAgICAgIGxldCBib2R5ID0gXCJcIjtcbiAgICAgICAgICBzeW50aGV0aWNSZXMud3JpdGVIZWFkID0gKHN0YXR1c0NvZGUpID0+IHtcbiAgICAgICAgICAgIHN0YXR1cyA9IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICByZXR1cm4gc3ludGhldGljUmVzO1xuICAgICAgICAgIH07XG4gICAgICAgICAgc3ludGhldGljUmVzLmVuZCA9IChiKSA9PiB7XG4gICAgICAgICAgICBib2R5ID0gYjtcbiAgICAgICAgICAgIHJldHVybiBzeW50aGV0aWNSZXM7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgdHJhbnNwb3J0LmhhbmRsZVBvc3RNZXNzYWdlKHJlcTIsIHN5bnRoZXRpY1Jlcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QuYm9keSA9PT0gXCJvYmplY3RcIiAmJiByZXF1ZXN0LmJvZHkgJiYgXCJtZXRob2RcIiBpbiByZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgIGV2ZW50UmVzLnJlcXVlc3RDb21wbGV0ZWQocmVxdWVzdC5ib2R5Lm1ldGhvZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UmVzLnJlcXVlc3RDb21wbGV0ZWQocmVxdWVzdC5ib2R5Lm1ldGhvZCwgYm9keSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXZlbnRSZXMuZXJyb3IoXG4gICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgIFwiRXJyb3IgaGFuZGxpbmcgU1NFIG1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgXCJzZXNzaW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgcmVkaXNQdWJsaXNoZXIyLnB1Ymxpc2goXG4gICAgICAgICAgICBgcmVzcG9uc2VzOiR7c2Vzc2lvbklkfToke3JlcXVlc3QucmVxdWVzdElkfWAsXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgbG9nSW5Db250ZXh0MihcbiAgICAgICAgICAgICAgXCJsb2dcIixcbiAgICAgICAgICAgICAgYFJlcXVlc3QgJHtzZXNzaW9uSWR9OiR7cmVxdWVzdC5yZXF1ZXN0SWR9IHN1Y2NlZWRlZDogJHtib2R5fWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0luQ29udGV4dDIoXG4gICAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgYE1lc3NhZ2UgZm9yICR7c2Vzc2lvbklkfToke3JlcXVlc3QucmVxdWVzdElkfSBmYWlsZWQgd2l0aCBzdGF0dXMgJHtzdGF0dXN9OiAke2JvZHl9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV2ZW50UmVzLmVycm9yKFxuICAgICAgICAgICAgICBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtzdGF0dXN9YCxcbiAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgXCJzZXNzaW9uXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncykge1xuICAgICAgICAgICAgbG9nZ2VyW2xvZy50eXBlXSguLi5sb2cubWVzc2FnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2dzID0gW107XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICAgIHlpZWxkIHJlZGlzMi5zdWJzY3JpYmUoYHJlcXVlc3RzOiR7c2Vzc2lvbklkfWAsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICBsb2dnZXIubG9nKGBTdWJzY3JpYmVkIHRvIHJlcXVlc3RzOiR7c2Vzc2lvbklkfWApO1xuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgbGV0IHJlc29sdmVUaW1lb3V0O1xuICAgICAgICBjb25zdCB3YWl0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZVRpbWVvdXQgPSByZXNvbHZlO1xuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoXCJtYXggZHVyYXRpb24gcmVhY2hlZFwiKTtcbiAgICAgICAgICB9LCAobWF4RHVyYXRpb24gIT0gbnVsbCA/IG1heER1cmF0aW9uIDogNjApICogMWUzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgeWllbGQgcmVkaXMyLnVuc3Vic2NyaWJlKGByZXF1ZXN0czoke3Nlc3Npb25JZH1gLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJEb25lXCIpO1xuICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSAyMDA7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIFwiYWJvcnRcIixcbiAgICAgICAgICAoKSA9PiByZXNvbHZlVGltZW91dChcImNsaWVudCBoYW5nIHVwXCIpXG4gICAgICAgICk7XG4gICAgICAgIHlpZWxkIHNlcnZlci5jb25uZWN0KHRyYW5zcG9ydCk7XG4gICAgICAgIGNvbnN0IGNsb3NlUmVhc29uID0geWllbGQgd2FpdFByb21pc2U7XG4gICAgICAgIGxvZ2dlci5sb2coY2xvc2VSZWFzb24pO1xuICAgICAgICB5aWVsZCBjbGVhbnVwKCk7XG4gICAgICB9IGVsc2UgaWYgKHVybC5wYXRobmFtZSA9PT0gc3NlTWVzc2FnZUVuZHBvaW50KSB7XG4gICAgICAgIGlmIChkaXNhYmxlU3NlKSB7XG4gICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgcmVzLmVuZChcIk5vdCBmb3VuZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZWRpczogcmVkaXMyLCByZWRpc1B1Ymxpc2hlcjogcmVkaXNQdWJsaXNoZXIyIH0gPSB5aWVsZCBpbml0aWFsaXplUmVkaXMoe1xuICAgICAgICAgIHJlZGlzVXJsLFxuICAgICAgICAgIGxvZ2dlclxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlJlY2VpdmVkIG1lc3NhZ2VcIik7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXEudGV4dCgpO1xuICAgICAgICBsZXQgcGFyc2VkQm9keTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRCb2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBhcnNlZEJvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwic2Vzc2lvbklkXCIpIHx8IFwiXCI7XG4gICAgICAgIGlmICghc2Vzc2lvbklkKSB7XG4gICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgICAgcmVzLmVuZChcIk5vIHNlc3Npb25JZCBwcm92aWRlZFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHVybDogcmVxLnVybCB8fCBcIlwiLFxuICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCB8fCBcIlwiLFxuICAgICAgICAgIGJvZHk6IHBhcnNlZEJvZHksXG4gICAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlcS5oZWFkZXJzLmVudHJpZXMoKSlcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRpbWVvdXQ7XG4gICAgICAgIGxldCBoYXNSZXNwb25kZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc2VuZFJlc3BvbnNlID0gKHN0YXR1cywgYm9keTIpID0+IHtcbiAgICAgICAgICBpZiAoIWhhc1Jlc3BvbmRlZCkge1xuICAgICAgICAgICAgaGFzUmVzcG9uZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgICAgICAgICAgcmVzLmVuZChib2R5Mik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB5aWVsZCByZWRpczIuc3Vic2NyaWJlKFxuICAgICAgICAgIGByZXNwb25zZXM6JHtzZXNzaW9uSWR9OiR7cmVxdWVzdElkfWAsXG4gICAgICAgICAgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgbWVzc2FnZTpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UoNTAwLCBcIkludGVybmFsIHNlcnZlciBlcnJvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHlpZWxkIHJlZGlzUHVibGlzaGVyMi5wdWJsaXNoKFxuICAgICAgICAgIGByZXF1ZXN0czoke3Nlc3Npb25JZH1gLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWRSZXF1ZXN0KVxuICAgICAgICApO1xuICAgICAgICBsb2dnZXIubG9nKGBQdWJsaXNoZWQgcmVxdWVzdHM6JHtzZXNzaW9uSWR9YCwgc2VyaWFsaXplZFJlcXVlc3QpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgeWllbGQgcmVkaXMyLnVuc3Vic2NyaWJlKGByZXNwb25zZXM6JHtzZXNzaW9uSWR9OiR7cmVxdWVzdElkfWApO1xuICAgICAgICAgIHNlbmRSZXNwb25zZSg0MDgsIFwiUmVxdWVzdCB0aW1lZCBvdXRcIik7XG4gICAgICAgIH0pLCAxMCAqIDFlMyk7XG4gICAgICAgIHJlcy5vbihcImNsb3NlXCIsICgpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICBoYXNSZXNwb25kZWQgPSB0cnVlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB5aWVsZCByZWRpczIudW5zdWJzY3JpYmUoYHJlc3BvbnNlczoke3Nlc3Npb25JZH06JHtyZXF1ZXN0SWR9YCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gNDA0O1xuICAgICAgICByZXMuZW5kKFwiTm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRmFrZUluY29taW5nTWVzc2FnZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG1ldGhvZCA9IFwiR0VUXCIsXG4gICAgdXJsID0gXCIvXCIsXG4gICAgaGVhZGVycyA9IHt9LFxuICAgIGJvZHkgPSBudWxsLFxuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQoKVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGUoKTtcbiAgcmVhZGFibGUuX3JlYWQgPSAoKSA9PiB7XG4gIH07XG4gIGlmIChib2R5KSB7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZWFkYWJsZS5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICByZWFkYWJsZS5wdXNoKGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBib2R5U3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICByZWFkYWJsZS5wdXNoKGJvZHlTdHJpbmcpO1xuICAgIH1cbiAgICByZWFkYWJsZS5wdXNoKG51bGwpO1xuICB9IGVsc2Uge1xuICAgIHJlYWRhYmxlLnB1c2gobnVsbCk7XG4gIH1cbiAgY29uc3QgcmVxID0gbmV3IEluY29taW5nTWVzc2FnZShzb2NrZXQpO1xuICByZXEubWV0aG9kID0gbWV0aG9kO1xuICByZXEudXJsID0gdXJsO1xuICByZXEuaGVhZGVycyA9IGhlYWRlcnM7XG4gIGNvbnN0IGF1dGggPSBvcHRpb25zLmF1dGggfHwgZ2V0QXV0aENvbnRleHQoKTtcbiAgaWYgKGF1dGgpIHtcbiAgICByZXEuYXV0aCA9IGF1dGg7XG4gIH1cbiAgcmVxLnB1c2ggPSByZWFkYWJsZS5wdXNoLmJpbmQocmVhZGFibGUpO1xuICByZXEucmVhZCA9IHJlYWRhYmxlLnJlYWQuYmluZChyZWFkYWJsZSk7XG4gIHJlcS5vbiA9IHJlYWRhYmxlLm9uLmJpbmQocmVhZGFibGUpO1xuICByZXEucGlwZSA9IHJlYWRhYmxlLnBpcGUuYmluZChyZWFkYWJsZSk7XG4gIHJldHVybiByZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2ZXJSZXNwb25zZUFkYXB0ZXIoc2lnbmFsLCBmbikge1xuICBsZXQgd3JpdGVIZWFkUmVzb2x2ZXI7XG4gIGNvbnN0IHdyaXRlSGVhZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHdyaXRlSGVhZFJlc29sdmVyID0gcmVzb2x2ZTtcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCBzaG91bGRDbG9zZSA9IGZhbHNlO1xuICAgIGxldCB3cm90ZUhlYWQgPSBmYWxzZTtcbiAgICBsZXQgc3RhdHVzQ29kZSA9IDIwMDtcbiAgICBsZXQgaGVhZGVycztcbiAgICBjb25zdCB3cml0ZUhlYWQgPSAoY29kZSwgaGVhZGVyc0FyZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBoZWFkZXJzQXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXR1cyBtZXNzYWdlIG9mIHdyaXRlSGVhZCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgc3RhdHVzQ29kZSA9IGNvZGU7XG4gICAgICBoZWFkZXJzID0gaGVhZGVyc0FyZztcbiAgICAgIHdyb3RlSGVhZCA9IHRydWU7XG4gICAgICB3cml0ZUhlYWRSZXNvbHZlcih7XG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZha2VTZXJ2ZXJSZXNwb25zZTtcbiAgICB9O1xuICAgIGNvbnN0IGJ1ZmZlcmVkRGF0YSA9IFtdO1xuICAgIGNvbnN0IHdyaXRlID0gKGNodW5rLCBlbmNvZGluZykgPT4ge1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIXdyb3RlSGVhZCkge1xuICAgICAgICB3cml0ZUhlYWQoc3RhdHVzQ29kZSwgaGVhZGVycyk7XG4gICAgICB9XG4gICAgICBpZiAoIWNvbnRyb2xsZXIpIHtcbiAgICAgICAgYnVmZmVyZWREYXRhLnB1c2gobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGNodW5rKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShjaHVuaykpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBldmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgY29uc3QgZmFrZVNlcnZlclJlc3BvbnNlID0ge1xuICAgICAgd3JpdGVIZWFkLFxuICAgICAgd3JpdGUsXG4gICAgICBlbmQ6IChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgd3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250cm9sbGVyKSB7XG4gICAgICAgICAgc2hvdWxkQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWtlU2VydmVyUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFrZVNlcnZlclJlc3BvbnNlO1xuICAgICAgfSxcbiAgICAgIG9uOiAoZXZlbnQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIGV2ZW50RW1pdHRlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZmFrZVNlcnZlclJlc3BvbnNlO1xuICAgICAgfSxcbiAgICAgIGdldCBzdGF0dXNDb2RlKCkge1xuICAgICAgICByZXR1cm4gc3RhdHVzQ29kZTtcbiAgICAgIH0sXG4gICAgICBzZXQgc3RhdHVzQ29kZShjb2RlKSB7XG4gICAgICAgIHN0YXR1c0NvZGUgPSBjb2RlO1xuICAgICAgICBpZiAod3JvdGVIZWFkKSB7XG4gICAgICAgICAgd3JpdGVIZWFkUmVzb2x2ZXIoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICBldmVudEVtaXR0ZXIuZW1pdChcImNsb3NlXCIpO1xuICAgIH0pO1xuICAgIHZvaWQgZm4oZmFrZVNlcnZlclJlc3BvbnNlKTtcbiAgICB2b2lkICgoKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBoZWFkID0geWllbGQgd3JpdGVIZWFkUHJvbWlzZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGMpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBjO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBidWZmZXJlZERhdGEpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAge1xuICAgICAgICAgIHN0YXR1czogaGVhZC5zdGF0dXNDb2RlLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWQuaGVhZGVyc1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfSkpKCk7XG4gIH0pO1xufVxuXG4vLyBzcmMvbmV4dC9pbmRleC50c1xuZnVuY3Rpb24gY3JlYXRlTWNwUm91dGVIYW5kbGVyKGluaXRpYWxpemVTZXJ2ZXIsIHNlcnZlck9wdGlvbnMsIGNvbmZpZykge1xuICBjb25zdCBtY3BIYW5kbGVyID0gaW5pdGlhbGl6ZU1jcEFwaUhhbmRsZXIoXG4gICAgaW5pdGlhbGl6ZVNlcnZlcixcbiAgICBzZXJ2ZXJPcHRpb25zLFxuICAgIGNvbmZpZ1xuICApO1xuICByZXR1cm4gKHJlcXVlc3QpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlU2VydmVyUmVzcG9uc2VBZGFwdGVyKHJlcXVlc3Quc2lnbmFsLCAocmVzKSA9PiB7XG4gICAgICBtY3BIYW5kbGVyKHJlcXVlc3QsIHJlcyk7XG4gICAgfSk7XG4gIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU1jcFJvdXRlSGFuZGxlciwgd2l0aEF1dGhDb250ZXh0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXQuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1GR1M2VU9YRC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FGS6UOXD.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/mcp-adapter/dist/index.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@vercel/mcp-adapter/dist/index.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMcpHandler: () => (/* reexport safe */ _chunk_FGS6UOXD_mjs__WEBPACK_IMPORTED_MODULE_0__.createMcpRouteHandler),\n/* harmony export */   experimental_withMcpAuth: () => (/* binding */ withMcpAuth)\n/* harmony export */ });\n/* harmony import */ var _chunk_FGS6UOXD_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-FGS6UOXD.mjs */ \"(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FGS6UOXD.mjs\");\n/* harmony import */ var _chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-FF57VHLH.mjs */ \"(rsc)/./node_modules/@vercel/mcp-adapter/dist/chunk-FF57VHLH.mjs\");\n/* harmony import */ var _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @modelcontextprotocol/sdk/server/auth/errors.js */ \"(rsc)/./node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js\");\n\n\n\n\n\nfunction withMcpAuth(handler, verifyToken, {\n  required = false,\n  resourceMetadataPath = \"/.well-known/oauth-protected-resource\",\n  requiredScopes\n} = {}) {\n  return (req) => (0,_chunk_FF57VHLH_mjs__WEBPACK_IMPORTED_MODULE_1__.__async)(this, null, function* () {\n    try {\n      const authHeader = req.headers.get(\"Authorization\");\n      const [type, token] = (authHeader == null ? void 0 : authHeader.split(\" \")) || [];\n      const bearerToken = (type == null ? void 0 : type.toLowerCase()) === \"bearer\" ? token : void 0;\n      const authInfo = yield verifyToken(req, bearerToken);\n      if (required && !authInfo) {\n        throw new _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidTokenError(\"No authorization provided\");\n      }\n      if (!authInfo) {\n        return handler(req);\n      }\n      if (requiredScopes == null ? void 0 : requiredScopes.length) {\n        const hasAllScopes = requiredScopes.every(\n          (scope) => authInfo.scopes.includes(scope)\n        );\n        if (!hasAllScopes) {\n          throw new _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.InsufficientScopeError(\"Insufficient scope\");\n        }\n      }\n      if (authInfo.expiresAt && authInfo.expiresAt < Date.now() / 1e3) {\n        throw new _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidTokenError(\"Token has expired\");\n      }\n      req.auth = authInfo;\n      return (0,_chunk_FGS6UOXD_mjs__WEBPACK_IMPORTED_MODULE_0__.withAuthContext)(authInfo, () => handler(req));\n    } catch (error) {\n      const origin = new URL(req.url).origin;\n      const resourceMetadataUrl = `${origin}${resourceMetadataPath}`;\n      if (error instanceof _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.InvalidTokenError) {\n        return new Response(JSON.stringify(error.toResponseObject()), {\n          status: 401,\n          headers: {\n            \"WWW-Authenticate\": `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\", resource_metadata=\"${resourceMetadataUrl}\"`,\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } else if (error instanceof _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.InsufficientScopeError) {\n        return new Response(JSON.stringify(error.toResponseObject()), {\n          status: 403,\n          headers: {\n            \"WWW-Authenticate\": `Bearer error=\"${error.errorCode}\", error_description=\"${error.message}\", resource_metadata=\"${resourceMetadataUrl}\"`,\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } else if (error instanceof _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.ServerError) {\n        return new Response(JSON.stringify(error.toResponseObject()), {\n          status: 500,\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } else {\n        console.error(\"Unexpected error authenticating bearer token:\", error);\n        const serverError = new _modelcontextprotocol_sdk_server_auth_errors_js__WEBPACK_IMPORTED_MODULE_2__.ServerError(\"Internal Server Error\");\n        return new Response(JSON.stringify(serverError.toResponseObject()), {\n          status: 500,\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      }\n    }\n  });\n}\n\n\n//# sourceMappingURL=out.js.map\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9tY3AtYWRhcHRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1RDtBQUMwQjtBQUNsQztBQUMwRTs7QUFFekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixrQkFBa0IsNERBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhGQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUdBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4RkFBaUI7QUFDbkM7QUFDQTtBQUNBLGFBQWEsb0VBQWU7QUFDNUIsTUFBTTtBQUNOO0FBQ0EscUNBQXFDLE9BQU8sRUFBRSxxQkFBcUI7QUFDbkUsMkJBQTJCLDhGQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCLHdCQUF3QixjQUFjLHdCQUF3QixvQkFBb0I7QUFDbko7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRLDBCQUEwQixtR0FBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQix3QkFBd0IsY0FBYyx3QkFBd0Isb0JBQW9CO0FBQ25KO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSwwQkFBMEIsd0ZBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0Msd0ZBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVtRDtBQUNuRDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9nbHUvUHJvamVjdHMvYWxsL2NsYXVkZS1leHQvbm9kZV9tb2R1bGVzL0B2ZXJjZWwvbWNwLWFkYXB0ZXIvZGlzdC9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2l0aEF1dGhDb250ZXh0IH0gZnJvbSAnLi9jaHVuay1GR1M2VU9YRC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTWNwUm91dGVIYW5kbGVyIGFzIGNyZWF0ZU1jcEhhbmRsZXIgfSBmcm9tICcuL2NodW5rLUZHUzZVT1hELm1qcyc7XG5pbXBvcnQgeyBfX2FzeW5jIH0gZnJvbSAnLi9jaHVuay1GRjU3VkhMSC5tanMnO1xuaW1wb3J0IHsgSW52YWxpZFRva2VuRXJyb3IsIEluc3VmZmljaWVudFNjb3BlRXJyb3IsIFNlcnZlckVycm9yIH0gZnJvbSAnQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvYXV0aC9lcnJvcnMuanMnO1xuXG5mdW5jdGlvbiB3aXRoTWNwQXV0aChoYW5kbGVyLCB2ZXJpZnlUb2tlbiwge1xuICByZXF1aXJlZCA9IGZhbHNlLFxuICByZXNvdXJjZU1ldGFkYXRhUGF0aCA9IFwiLy53ZWxsLWtub3duL29hdXRoLXByb3RlY3RlZC1yZXNvdXJjZVwiLFxuICByZXF1aXJlZFNjb3Blc1xufSA9IHt9KSB7XG4gIHJldHVybiAocmVxKSA9PiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXIgPSByZXEuaGVhZGVycy5nZXQoXCJBdXRob3JpemF0aW9uXCIpO1xuICAgICAgY29uc3QgW3R5cGUsIHRva2VuXSA9IChhdXRoSGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBhdXRoSGVhZGVyLnNwbGl0KFwiIFwiKSkgfHwgW107XG4gICAgICBjb25zdCBiZWFyZXJUb2tlbiA9ICh0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLnRvTG93ZXJDYXNlKCkpID09PSBcImJlYXJlclwiID8gdG9rZW4gOiB2b2lkIDA7XG4gICAgICBjb25zdCBhdXRoSW5mbyA9IHlpZWxkIHZlcmlmeVRva2VuKHJlcSwgYmVhcmVyVG9rZW4pO1xuICAgICAgaWYgKHJlcXVpcmVkICYmICFhdXRoSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXCJObyBhdXRob3JpemF0aW9uIHByb3ZpZGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhdXRoSW5mbykge1xuICAgICAgICByZXR1cm4gaGFuZGxlcihyZXEpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVpcmVkU2NvcGVzID09IG51bGwgPyB2b2lkIDAgOiByZXF1aXJlZFNjb3Blcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaGFzQWxsU2NvcGVzID0gcmVxdWlyZWRTY29wZXMuZXZlcnkoXG4gICAgICAgICAgKHNjb3BlKSA9PiBhdXRoSW5mby5zY29wZXMuaW5jbHVkZXMoc2NvcGUpXG4gICAgICAgICk7XG4gICAgICAgIGlmICghaGFzQWxsU2NvcGVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEluc3VmZmljaWVudFNjb3BlRXJyb3IoXCJJbnN1ZmZpY2llbnQgc2NvcGVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhdXRoSW5mby5leHBpcmVzQXQgJiYgYXV0aEluZm8uZXhwaXJlc0F0IDwgRGF0ZS5ub3coKSAvIDFlMykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRva2VuRXJyb3IoXCJUb2tlbiBoYXMgZXhwaXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIHJlcS5hdXRoID0gYXV0aEluZm87XG4gICAgICByZXR1cm4gd2l0aEF1dGhDb250ZXh0KGF1dGhJbmZvLCAoKSA9PiBoYW5kbGVyKHJlcSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBuZXcgVVJMKHJlcS51cmwpLm9yaWdpbjtcbiAgICAgIGNvbnN0IHJlc291cmNlTWV0YWRhdGFVcmwgPSBgJHtvcmlnaW59JHtyZXNvdXJjZU1ldGFkYXRhUGF0aH1gO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSW52YWxpZFRva2VuRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShlcnJvci50b1Jlc3BvbnNlT2JqZWN0KCkpLCB7XG4gICAgICAgICAgc3RhdHVzOiA0MDEsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJXV1ctQXV0aGVudGljYXRlXCI6IGBCZWFyZXIgZXJyb3I9XCIke2Vycm9yLmVycm9yQ29kZX1cIiwgZXJyb3JfZGVzY3JpcHRpb249XCIke2Vycm9yLm1lc3NhZ2V9XCIsIHJlc291cmNlX21ldGFkYXRhPVwiJHtyZXNvdXJjZU1ldGFkYXRhVXJsfVwiYCxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJbnN1ZmZpY2llbnRTY29wZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoZXJyb3IudG9SZXNwb25zZU9iamVjdCgpKSwge1xuICAgICAgICAgIHN0YXR1czogNDAzLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiV1dXLUF1dGhlbnRpY2F0ZVwiOiBgQmVhcmVyIGVycm9yPVwiJHtlcnJvci5lcnJvckNvZGV9XCIsIGVycm9yX2Rlc2NyaXB0aW9uPVwiJHtlcnJvci5tZXNzYWdlfVwiLCByZXNvdXJjZV9tZXRhZGF0YT1cIiR7cmVzb3VyY2VNZXRhZGF0YVVybH1cImAsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgU2VydmVyRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShlcnJvci50b1Jlc3BvbnNlT2JqZWN0KCkpLCB7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3IgYXV0aGVudGljYXRpbmcgYmVhcmVyIHRva2VuOlwiLCBlcnJvcik7XG4gICAgICAgIGNvbnN0IHNlcnZlckVycm9yID0gbmV3IFNlcnZlckVycm9yKFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHNlcnZlckVycm9yLnRvUmVzcG9uc2VPYmplY3QoKSksIHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgd2l0aE1jcEF1dGggYXMgZXhwZXJpbWVudGFsX3dpdGhNY3BBdXRoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXQuanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/mcp-adapter/dist/index.mjs\n");

/***/ })

};
;